use allot_lib::{OpPrim1, OpPrim2, Operation, RawType, Register, Type};

use crate::memory::Registers;

// TODO: Possible add functions
#[cfg(feature = "fast-math")]
mod math {
    fn add(a: usize, b: usize) -> Option<usize> {
        Some(a + b)
    }
}

#[cfg(not(feature = "fast-math"))]
mod math {
    fn add(a: usize, b: usize) -> Option<usize> {
        a.checked_add(b)
    }
}
//

// TODO: Should casting be allowed for NUMBER->String or should that be a
// library function?
pub fn cast(t: &Type, raw: RawType) -> Type {
    match t {
        Type::Int8(v) => match raw {
            RawType::Int8 => Type::Int8(*v),
            RawType::Int16 => Type::Int16(*v as i16),
            RawType::Int32 => Type::Int32(*v as i32),
            RawType::Int => Type::Int(*v as isize),
            RawType::Int64 => Type::Int64(*v as i64),
            RawType::Int128 => Type::Int128(*v as i128),
            RawType::UInt8 => Type::UInt8(*v as u8),
            RawType::UInt16 => Type::UInt16(*v as u16),
            RawType::UInt32 => Type::UInt32(*v as u32),
            RawType::UInt => Type::UInt(*v as usize),
            RawType::UInt64 => Type::UInt64(*v as u64),
            RawType::UInt128 => Type::UInt128(*v as u128),
            RawType::Float32 => Type::Float32(*v as f32),
            RawType::Float64 => Type::Float64(*v as f64),
            RawType::Char => Type::Char(char::from_u32(*v as u32).unwrap()),
            RawType::String => Type::String(v.to_string()),
            _ => panic!("Cannot cast {:?} into {:?}.", t, raw),
        },
        Type::Int16(v) => match raw {
            RawType::Int8 => Type::Int8(*v as i8),
            RawType::Int16 => Type::Int16(*v),
            RawType::Int32 => Type::Int32(*v as i32),
            RawType::Int => Type::Int(*v as isize),
            RawType::Int64 => Type::Int64(*v as i64),
            RawType::Int128 => Type::Int128(*v as i128),
            RawType::UInt8 => Type::UInt8(*v as u8),
            RawType::UInt16 => Type::UInt16(*v as u16),
            RawType::UInt32 => Type::UInt32(*v as u32),
            RawType::UInt => Type::UInt(*v as usize),
            RawType::UInt64 => Type::UInt64(*v as u64),
            RawType::UInt128 => Type::UInt128(*v as u128),
            RawType::Float32 => Type::Float32(*v as f32),
            RawType::Float64 => Type::Float64(*v as f64),
            RawType::Char => Type::Char(char::from_u32(*v as u32).unwrap()),
            RawType::String => Type::String(v.to_string()),
            _ => panic!("Cannot cast {:?} into {:?}.", t, raw),
        },
        Type::Int32(v) => match raw {
            RawType::Int8 => Type::Int8(*v as i8),
            RawType::Int16 => Type::Int16(*v as i16),
            RawType::Int32 => Type::Int32(*v),
            RawType::Int => Type::Int(*v as isize),
            RawType::Int64 => Type::Int64(*v as i64),
            RawType::Int128 => Type::Int128(*v as i128),
            RawType::UInt8 => Type::UInt8(*v as u8),
            RawType::UInt16 => Type::UInt16(*v as u16),
            RawType::UInt32 => Type::UInt32(*v as u32),
            RawType::UInt => Type::UInt(*v as usize),
            RawType::UInt64 => Type::UInt64(*v as u64),
            RawType::UInt128 => Type::UInt128(*v as u128),
            RawType::Float32 => Type::Float32(*v as f32),
            RawType::Float64 => Type::Float64(*v as f64),
            RawType::Char => Type::Char(char::from_u32(*v as u32).unwrap()),
            RawType::String => Type::String(v.to_string()),
            _ => panic!("Cannot cast {:?} into {:?}.", t, raw),
        },
        Type::Int(v) => match raw {
            RawType::Int8 => Type::Int8(*v as i8),
            RawType::Int16 => Type::Int16(*v as i16),
            RawType::Int32 => Type::Int32(*v as i32),
            RawType::Int => Type::Int(*v),
            RawType::Int64 => Type::Int64(*v as i64),
            RawType::Int128 => Type::Int128(*v as i128),
            RawType::UInt8 => Type::UInt8(*v as u8),
            RawType::UInt16 => Type::UInt16(*v as u16),
            RawType::UInt32 => Type::UInt32(*v as u32),
            RawType::UInt => Type::UInt(*v as usize),
            RawType::UInt64 => Type::UInt64(*v as u64),
            RawType::UInt128 => Type::UInt128(*v as u128),
            RawType::Float32 => Type::Float32(*v as f32),
            RawType::Float64 => Type::Float64(*v as f64),
            RawType::Char => Type::Char(char::from_u32(*v as u32).unwrap()),
            RawType::String => Type::String(v.to_string()),
            _ => panic!("Cannot cast {:?} into {:?}.", t, raw),
        },
        Type::Int64(v) => match raw {
            RawType::Int8 => Type::Int8(*v as i8),
            RawType::Int16 => Type::Int16(*v as i16),
            RawType::Int32 => Type::Int32(*v as i32),
            RawType::Int => Type::Int(*v as isize),
            RawType::Int64 => Type::Int64(*v),
            RawType::Int128 => Type::Int128(*v as i128),
            RawType::UInt8 => Type::UInt8(*v as u8),
            RawType::UInt16 => Type::UInt16(*v as u16),
            RawType::UInt32 => Type::UInt32(*v as u32),
            RawType::UInt => Type::UInt(*v as usize),
            RawType::UInt64 => Type::UInt64(*v as u64),
            RawType::UInt128 => Type::UInt128(*v as u128),
            RawType::Float32 => Type::Float32(*v as f32),
            RawType::Float64 => Type::Float64(*v as f64),
            RawType::Char => Type::Char(char::from_u32(*v as u32).unwrap()),
            RawType::String => Type::String(v.to_string()),
            _ => panic!("Cannot cast {:?} into {:?}.", t, raw),
        },
        Type::Int128(v) => match raw {
            RawType::Int8 => Type::Int8(*v as i8),
            RawType::Int16 => Type::Int16(*v as i16),
            RawType::Int32 => Type::Int32(*v as i32),
            RawType::Int => Type::Int(*v as isize),
            RawType::Int64 => Type::Int64(*v as i64),
            RawType::Int128 => Type::Int128(*v),
            RawType::UInt8 => Type::UInt8(*v as u8),
            RawType::UInt16 => Type::UInt16(*v as u16),
            RawType::UInt32 => Type::UInt32(*v as u32),
            RawType::UInt => Type::UInt(*v as usize),
            RawType::UInt64 => Type::UInt64(*v as u64),
            RawType::UInt128 => Type::UInt128(*v as u128),
            RawType::Float32 => Type::Float32(*v as f32),
            RawType::Float64 => Type::Float64(*v as f64),
            RawType::Char => Type::Char(char::from_u32(*v as u32).unwrap()),
            RawType::String => Type::String(v.to_string()),
            _ => panic!("Cannot cast {:?} into {:?}.", t, raw),
        },
        Type::UInt8(v) => match raw {
            RawType::Int8 => Type::Int8(*v as i8),
            RawType::Int16 => Type::Int16(*v as i16),
            RawType::Int32 => Type::Int32(*v as i32),
            RawType::Int => Type::Int(*v as isize),
            RawType::Int64 => Type::Int64(*v as i64),
            RawType::Int128 => Type::Int128(*v as i128),
            RawType::UInt8 => Type::UInt8(*v),
            RawType::UInt16 => Type::UInt16(*v as u16),
            RawType::UInt32 => Type::UInt32(*v as u32),
            RawType::UInt => Type::UInt(*v as usize),
            RawType::UInt64 => Type::UInt64(*v as u64),
            RawType::UInt128 => Type::UInt128(*v as u128),
            RawType::Float32 => Type::Float32(*v as f32),
            RawType::Float64 => Type::Float64(*v as f64),
            RawType::Char => Type::Char(*v as char),
            RawType::String => Type::String(v.to_string()),
            _ => panic!("Cannot cast {:?} into {:?}.", t, raw),
        },
        Type::UInt16(v) => match raw {
            RawType::Int8 => Type::Int8(*v as i8),
            RawType::Int16 => Type::Int16(*v as i16),
            RawType::Int32 => Type::Int32(*v as i32),
            RawType::Int => Type::Int(*v as isize),
            RawType::Int64 => Type::Int64(*v as i64),
            RawType::Int128 => Type::Int128(*v as i128),
            RawType::UInt8 => Type::UInt8(*v as u8),
            RawType::UInt16 => Type::UInt16(*v),
            RawType::UInt32 => Type::UInt32(*v as u32),
            RawType::UInt => Type::UInt(*v as usize),
            RawType::UInt64 => Type::UInt64(*v as u64),
            RawType::UInt128 => Type::UInt128(*v as u128),
            RawType::Float32 => Type::Float32(*v as f32),
            RawType::Float64 => Type::Float64(*v as f64),
            RawType::Char => Type::Char(char::from_u32(*v as u32).unwrap()),
            RawType::String => Type::String(v.to_string()),
            _ => panic!("Cannot cast {:?} into {:?}.", t, raw),
        },
        Type::UInt32(v) => match raw {
            RawType::Int8 => Type::Int8(*v as i8),
            RawType::Int16 => Type::Int16(*v as i16),
            RawType::Int32 => Type::Int32(*v as i32),
            RawType::Int => Type::Int(*v as isize),
            RawType::Int64 => Type::Int64(*v as i64),
            RawType::Int128 => Type::Int128(*v as i128),
            RawType::UInt8 => Type::UInt8(*v as u8),
            RawType::UInt16 => Type::UInt16(*v as u16),
            RawType::UInt32 => Type::UInt32(*v),
            RawType::UInt => Type::UInt(*v as usize),
            RawType::UInt64 => Type::UInt64(*v as u64),
            RawType::UInt128 => Type::UInt128(*v as u128),
            RawType::Float32 => Type::Float32(*v as f32),
            RawType::Float64 => Type::Float64(*v as f64),
            RawType::Char => Type::Char(char::from_u32(*v).unwrap()),
            RawType::String => Type::String(v.to_string()),
            _ => panic!("Cannot cast {:?} into {:?}.", t, raw),
        },
        Type::UInt(v) => match raw {
            RawType::Int8 => Type::Int8(*v as i8),
            RawType::Int16 => Type::Int16(*v as i16),
            RawType::Int32 => Type::Int32(*v as i32),
            RawType::Int => Type::Int(*v as isize),
            RawType::Int64 => Type::Int64(*v as i64),
            RawType::Int128 => Type::Int128(*v as i128),
            RawType::UInt8 => Type::UInt8(*v as u8),
            RawType::UInt16 => Type::UInt16(*v as u16),
            RawType::UInt32 => Type::UInt32(*v as u32),
            RawType::UInt => Type::UInt(*v),
            RawType::UInt64 => Type::UInt64(*v as u64),
            RawType::UInt128 => Type::UInt128(*v as u128),
            RawType::Float32 => Type::Float32(*v as f32),
            RawType::Float64 => Type::Float64(*v as f64),
            RawType::Char => Type::Char(char::from_u32(*v as u32).unwrap()),
            RawType::String => Type::String(v.to_string()),
            _ => panic!("Cannot cast {:?} into {:?}.", t, raw),
        },
        Type::UInt64(v) => match raw {
            RawType::Int8 => Type::Int8(*v as i8),
            RawType::Int16 => Type::Int16(*v as i16),
            RawType::Int32 => Type::Int32(*v as i32),
            RawType::Int => Type::Int(*v as isize),
            RawType::Int64 => Type::Int64(*v as i64),
            RawType::Int128 => Type::Int128(*v as i128),
            RawType::UInt8 => Type::UInt8(*v as u8),
            RawType::UInt16 => Type::UInt16(*v as u16),
            RawType::UInt32 => Type::UInt32(*v as u32),
            RawType::UInt => Type::UInt(*v as usize),
            RawType::UInt64 => Type::UInt64(*v),
            RawType::UInt128 => Type::UInt128(*v as u128),
            RawType::Float32 => Type::Float32(*v as f32),
            RawType::Float64 => Type::Float64(*v as f64),
            RawType::Char => Type::Char(char::from_u32(*v as u32).unwrap()),
            RawType::String => Type::String(v.to_string()),
            _ => panic!("Cannot cast {:?} into {:?}.", t, raw),
        },
        Type::UInt128(v) => match raw {
            RawType::Int8 => Type::Int8(*v as i8),
            RawType::Int16 => Type::Int16(*v as i16),
            RawType::Int32 => Type::Int32(*v as i32),
            RawType::Int => Type::Int(*v as isize),
            RawType::Int64 => Type::Int64(*v as i64),
            RawType::Int128 => Type::Int128(*v as i128),
            RawType::UInt8 => Type::UInt8(*v as u8),
            RawType::UInt16 => Type::UInt16(*v as u16),
            RawType::UInt32 => Type::UInt32(*v as u32),
            RawType::UInt => Type::UInt(*v as usize),
            RawType::UInt64 => Type::UInt64(*v as u64),
            RawType::UInt128 => Type::UInt128(*v),
            RawType::Float32 => Type::Float32(*v as f32),
            RawType::Float64 => Type::Float64(*v as f64),
            RawType::Char => Type::Char(char::from_u32(*v as u32).unwrap()),
            RawType::String => Type::String(v.to_string()),
            _ => panic!("Cannot cast {:?} into {:?}.", t, raw),
        },
        Type::Float32(v) => match raw {
            RawType::Int8 => Type::Int8(*v as i8),
            RawType::Int16 => Type::Int16(*v as i16),
            RawType::Int32 => Type::Int32(*v as i32),
            RawType::Int => Type::Int(*v as isize),
            RawType::Int64 => Type::Int64(*v as i64),
            RawType::Int128 => Type::Int128(*v as i128),
            RawType::UInt8 => Type::UInt8(*v as u8),
            RawType::UInt16 => Type::UInt16(*v as u16),
            RawType::UInt32 => Type::UInt32(*v as u32),
            RawType::UInt => Type::UInt(*v as usize),
            RawType::UInt64 => Type::UInt64(*v as u64),
            RawType::UInt128 => Type::UInt128(*v as u128),
            RawType::Float32 => Type::Float32(*v),
            RawType::Float64 => Type::Float64(*v as f64),
            RawType::Char => Type::Char(char::from_u32(*v as u32).unwrap()),
            RawType::String => Type::String(v.to_string()),
            _ => panic!("Cannot cast {:?} into {:?}.", t, raw),
        },
        Type::Float64(v) => match raw {
            RawType::Int8 => Type::Int8(*v as i8),
            RawType::Int16 => Type::Int16(*v as i16),
            RawType::Int32 => Type::Int32(*v as i32),
            RawType::Int => Type::Int(*v as isize),
            RawType::Int64 => Type::Int64(*v as i64),
            RawType::Int128 => Type::Int128(*v as i128),
            RawType::UInt8 => Type::UInt8(*v as u8),
            RawType::UInt16 => Type::UInt16(*v as u16),
            RawType::UInt32 => Type::UInt32(*v as u32),
            RawType::UInt => Type::UInt(*v as usize),
            RawType::UInt64 => Type::UInt64(*v as u64),
            RawType::UInt128 => Type::UInt128(*v as u128),
            RawType::Float32 => Type::Float32(*v as f32),
            RawType::Float64 => Type::Float64(*v),
            RawType::Char => Type::Char(char::from_u32(*v as u32).unwrap()),
            RawType::String => Type::String(v.to_string()),
            _ => panic!("Cannot cast {:?} into {:?}.", t, raw),
        },
        Type::Char(v) => match raw {
            RawType::Int8 => Type::Int8(*v as i8),
            RawType::Int16 => Type::Int16(*v as i16),
            RawType::Int32 => Type::Int32(*v as i32),
            RawType::Int => Type::Int(*v as isize),
            RawType::Int64 => Type::Int64(*v as i64),
            RawType::Int128 => Type::Int128(*v as i128),
            RawType::UInt8 => Type::UInt8(*v as u8),
            RawType::UInt16 => Type::UInt16(*v as u16),
            RawType::UInt32 => Type::UInt32(*v as u32),
            RawType::UInt => Type::UInt(*v as usize),
            RawType::UInt64 => Type::UInt64(*v as u64),
            RawType::UInt128 => Type::UInt128(*v as u128),
            RawType::Char => Type::Char(*v),
            RawType::String => Type::String(v.to_string()),
            _ => panic!("Cannot cast {:?} into {:?}.", t, raw),
        },
        _ => panic!("{:?} cannot be cast.", t),
    }
}

pub fn solve(op: &Operation, registers: &mut Registers, regs: &[Register; 2]) {
    match op {
        Operation::Prim1(op) => {
            let v = registers.take(regs[0]);
            let t = solve_1(op, v);
            registers.insert(regs[0], t);
        }
        Operation::Prim2(op) => {
            let v1 = registers.clone(regs[0]);
            let v2 = registers.clone(regs[1]);
            let t = solve_2(op, v1, v2);
            registers.insert(regs[0], t);
        }
    }
}

pub fn solve_1(op: &OpPrim1, t: Type) -> Type {
    match op {
        OpPrim1::Increment => match t {
            Type::Int8(v) => Type::Int8(v + 1),
            Type::Int16(v) => Type::Int16(v + 1),
            Type::Int32(v) => Type::Int32(v + 1),
            Type::Int(v) => Type::Int(v + 1),
            Type::Int64(v) => Type::Int64(v + 1),
            Type::Int128(v) => Type::Int128(v + 1),
            Type::UInt8(v) => Type::UInt8(v + 1),
            Type::UInt16(v) => Type::UInt16(v + 1),
            Type::UInt32(v) => Type::UInt32(v + 1),
            Type::UInt(v) => Type::UInt(v + 1),
            Type::UInt64(v) => Type::UInt64(v + 1),
            Type::UInt128(v) => Type::UInt128(v + 1),
            Type::Float32(v) => Type::Float32(v + 1.0),
            Type::Float64(v) => Type::Float64(v + 1.0),
            Type::Char(v) => Type::Char(char::from_u32(v as u32 + 1).unwrap()),
            _ => panic!("Increment only works on number types."),
        },
        OpPrim1::Decrement => match t {
            Type::Int8(v) => Type::Int8(v - 1),
            Type::Int16(v) => Type::Int16(v - 1),
            Type::Int32(v) => Type::Int32(v - 1),
            Type::Int(v) => Type::Int(v - 1),
            Type::Int64(v) => Type::Int64(v - 1),
            Type::Int128(v) => Type::Int128(v - 1),
            Type::UInt8(v) => Type::UInt8(v - 1),
            Type::UInt16(v) => Type::UInt16(v - 1),
            Type::UInt32(v) => Type::UInt32(v - 1),
            Type::UInt(v) => Type::UInt(v - 1),
            Type::UInt64(v) => Type::UInt64(v - 1),
            Type::UInt128(v) => Type::UInt128(v - 1),
            Type::Float32(v) => Type::Float32(v - 1.0),
            Type::Float64(v) => Type::Float64(v - 1.0),
            Type::Char(v) => Type::Char(char::from_u32(v as u32 - 1).unwrap()),
            _ => panic!("Decrement only works on number types."),
        },
        OpPrim1::Not => match t {
            Type::Boolean(v) => Type::Boolean(!v),
            _ => panic!("Not only works on boolean type."),
        },
        OpPrim1::BitwiseNot => match t {
            Type::Int8(v) => Type::Int8(!v),
            Type::Int16(v) => Type::Int16(!v),
            Type::Int32(v) => Type::Int32(!v),
            Type::Int(v) => Type::Int(!v),
            Type::Int64(v) => Type::Int64(!v),
            Type::Int128(v) => Type::Int128(!v),
            Type::UInt8(v) => Type::UInt8(!v),
            Type::UInt16(v) => Type::UInt16(!v),
            Type::UInt32(v) => Type::UInt32(!v),
            Type::UInt(v) => Type::UInt(!v),
            Type::UInt64(v) => Type::UInt64(!v),
            Type::UInt128(v) => Type::UInt128(!v),
            _ => panic!("BitwiseNot only works on int number types."),
        },
    }
}

pub fn solve_2(op: &OpPrim2, t1: Type, t2: Type) -> Type {
    match op {
        OpPrim2::Add => match (t1, t2) {
            (Type::Int8(v1), Type::Int8(v2)) => Type::Int8(v1 + v2),
            (Type::Int16(v1), Type::Int16(v2)) => Type::Int16(v1 + v2),
            (Type::Int32(v1), Type::Int32(v2)) => Type::Int32(v1 + v2),
            (Type::Int(v1), Type::Int(v2)) => Type::Int(v1 + v2),
            (Type::Int64(v1), Type::Int64(v2)) => Type::Int64(v1 + v2),
            (Type::Int128(v1), Type::Int128(v2)) => Type::Int128(v1 + v2),
            (Type::UInt8(v1), Type::UInt8(v2)) => Type::UInt8(v1 + v2),
            (Type::UInt16(v1), Type::UInt16(v2)) => Type::UInt16(v1 + v2),
            (Type::UInt32(v1), Type::UInt32(v2)) => Type::UInt32(v1 + v2),
            (Type::UInt(v1), Type::UInt(v2)) => Type::UInt(v1 + v2),
            (Type::UInt64(v1), Type::UInt64(v2)) => Type::UInt64(v1 + v2),
            (Type::UInt128(v1), Type::UInt128(v2)) => Type::UInt128(v1 + v2),
            (Type::Float32(v1), Type::Float32(v2)) => Type::Float32(v1 + v2),
            (Type::Float64(v1), Type::Float64(v2)) => Type::Float64(v1 + v2),
            (Type::Char(v1), Type::Char(v2)) => {
                Type::Char(char::from_u32(v1 as u32 + v2 as u32).unwrap())
            }
            (Type::String(mut v1), Type::String(v2)) => Type::String({
                v1.push_str(v2.as_str());
                v1
            }),
            _ => panic!("Add only works on two of the same number types and two strings."),
        },
        OpPrim2::Subtract => match (t1, t2) {
            (Type::Int8(v1), Type::Int8(v2)) => Type::Int8(v1 - v2),
            (Type::Int16(v1), Type::Int16(v2)) => Type::Int16(v1 - v2),
            (Type::Int32(v1), Type::Int32(v2)) => Type::Int32(v1 - v2),
            (Type::Int(v1), Type::Int(v2)) => Type::Int(v1 - v2),
            (Type::Int64(v1), Type::Int64(v2)) => Type::Int64(v1 - v2),
            (Type::Int128(v1), Type::Int128(v2)) => Type::Int128(v1 - v2),
            (Type::UInt8(v1), Type::UInt8(v2)) => Type::UInt8(v1 - v2),
            (Type::UInt16(v1), Type::UInt16(v2)) => Type::UInt16(v1 - v2),
            (Type::UInt32(v1), Type::UInt32(v2)) => Type::UInt32(v1 - v2),
            (Type::UInt(v1), Type::UInt(v2)) => Type::UInt(v1 - v2),
            (Type::UInt64(v1), Type::UInt64(v2)) => Type::UInt64(v1 - v2),
            (Type::UInt128(v1), Type::UInt128(v2)) => Type::UInt128(v1 - v2),
            (Type::Float32(v1), Type::Float32(v2)) => Type::Float32(v1 - v2),
            (Type::Float64(v1), Type::Float64(v2)) => Type::Float64(v1 - v2),
            (Type::Char(v1), Type::Char(v2)) => {
                Type::Char(char::from_u32(v1 as u32 - v2 as u32).unwrap())
            }
            _ => panic!("Subtract only works on two of the same number types."),
        },
        OpPrim2::Multiplication => match (t1, t2) {
            (Type::Int8(v1), Type::Int8(v2)) => Type::Int8(v1 * v2),
            (Type::Int16(v1), Type::Int16(v2)) => Type::Int16(v1 * v2),
            (Type::Int32(v1), Type::Int32(v2)) => Type::Int32(v1 * v2),
            (Type::Int(v1), Type::Int(v2)) => Type::Int(v1 * v2),
            (Type::Int64(v1), Type::Int64(v2)) => Type::Int64(v1 * v2),
            (Type::Int128(v1), Type::Int128(v2)) => Type::Int128(v1 * v2),
            (Type::UInt8(v1), Type::UInt8(v2)) => Type::UInt8(v1 * v2),
            (Type::UInt16(v1), Type::UInt16(v2)) => Type::UInt16(v1 * v2),
            (Type::UInt32(v1), Type::UInt32(v2)) => Type::UInt32(v1 * v2),
            (Type::UInt(v1), Type::UInt(v2)) => Type::UInt(v1 * v2),
            (Type::UInt64(v1), Type::UInt64(v2)) => Type::UInt64(v1 * v2),
            (Type::UInt128(v1), Type::UInt128(v2)) => Type::UInt128(v1 * v2),
            (Type::Float32(v1), Type::Float32(v2)) => Type::Float32(v1 * v2),
            (Type::Float64(v1), Type::Float64(v2)) => Type::Float64(v1 * v2),
            (Type::Char(v1), Type::Char(v2)) => {
                Type::Char(char::from_u32(v1 as u32 * v2 as u32).unwrap())
            }
            _ => panic!("Multiplication only works on two of the same number types."),
        },
        OpPrim2::Division => match (t1, t2) {
            (Type::Int8(v1), Type::Int8(v2)) => Type::Int8(v1 / v2),
            (Type::Int16(v1), Type::Int16(v2)) => Type::Int16(v1 / v2),
            (Type::Int32(v1), Type::Int32(v2)) => Type::Int32(v1 / v2),
            (Type::Int(v1), Type::Int(v2)) => Type::Int(v1 / v2),
            (Type::Int64(v1), Type::Int64(v2)) => Type::Int64(v1 / v2),
            (Type::Int128(v1), Type::Int128(v2)) => Type::Int128(v1 / v2),
            (Type::UInt8(v1), Type::UInt8(v2)) => Type::UInt8(v1 / v2),
            (Type::UInt16(v1), Type::UInt16(v2)) => Type::UInt16(v1 / v2),
            (Type::UInt32(v1), Type::UInt32(v2)) => Type::UInt32(v1 / v2),
            (Type::UInt(v1), Type::UInt(v2)) => Type::UInt(v1 / v2),
            (Type::UInt64(v1), Type::UInt64(v2)) => Type::UInt64(v1 / v2),
            (Type::UInt128(v1), Type::UInt128(v2)) => Type::UInt128(v1 / v2),
            (Type::Float32(v1), Type::Float32(v2)) => Type::Float32(v1 / v2),
            (Type::Float64(v1), Type::Float64(v2)) => Type::Float64(v1 / v2),
            (Type::Char(v1), Type::Char(v2)) => {
                Type::Char(char::from_u32(v1 as u32 / v2 as u32).unwrap())
            }
            _ => panic!("Division only works on two of the same number types."),
        },
        OpPrim2::Modulus => match (t1, t2) {
            (Type::Int8(v1), Type::Int8(v2)) => Type::Int8(v1 % v2),
            (Type::Int16(v1), Type::Int16(v2)) => Type::Int16(v1 % v2),
            (Type::Int32(v1), Type::Int32(v2)) => Type::Int32(v1 % v2),
            (Type::Int(v1), Type::Int(v2)) => Type::Int(v1 % v2),
            (Type::Int64(v1), Type::Int64(v2)) => Type::Int64(v1 % v2),
            (Type::Int128(v1), Type::Int128(v2)) => Type::Int128(v1 % v2),
            (Type::UInt8(v1), Type::UInt8(v2)) => Type::UInt8(v1 % v2),
            (Type::UInt16(v1), Type::UInt16(v2)) => Type::UInt16(v1 % v2),
            (Type::UInt32(v1), Type::UInt32(v2)) => Type::UInt32(v1 % v2),
            (Type::UInt(v1), Type::UInt(v2)) => Type::UInt(v1 % v2),
            (Type::UInt64(v1), Type::UInt64(v2)) => Type::UInt64(v1 % v2),
            (Type::UInt128(v1), Type::UInt128(v2)) => Type::UInt128(v1 % v2),
            (Type::Float32(v1), Type::Float32(v2)) => Type::Float32(v1 % v2),
            (Type::Float64(v1), Type::Float64(v2)) => Type::Float64(v1 % v2),
            (Type::Char(v1), Type::Char(v2)) => {
                Type::Char(char::from_u32(v1 as u32 % v2 as u32).unwrap())
            }
            _ => panic!("Modulus only works on two of the same number types."),
        },
        OpPrim2::And => match (t1, t2) {
            (Type::Boolean(v1), Type::Boolean(v2)) => Type::Boolean(v1 && v2),
            _ => panic!("Add only works on two of the same boolean type."),
        },
        OpPrim2::Or => match (t1, t2) {
            (Type::Boolean(v1), Type::Boolean(v2)) => Type::Boolean(v1 || v2),
            _ => panic!("Or only works on two of the same boolean type."),
        },
        OpPrim2::Xor => match (t1, t2) {
            (Type::Boolean(v1), Type::Boolean(v2)) => Type::Boolean(v1 ^ v2),
            _ => panic!("Xor only works on two of the same boolean type."),
        },
        OpPrim2::Equal => match (t1, t2) {
            (Type::None, Type::None) => Type::Boolean(true),
            (Type::Int8(v1), Type::Int8(v2)) => Type::Boolean(v1 == v2),
            (Type::Int16(v1), Type::Int16(v2)) => Type::Boolean(v1 == v2),
            (Type::Int32(v1), Type::Int32(v2)) => Type::Boolean(v1 == v2),
            (Type::Int(v1), Type::Int(v2)) => Type::Boolean(v1 == v2),
            (Type::Int64(v1), Type::Int64(v2)) => Type::Boolean(v1 == v2),
            (Type::Int128(v1), Type::Int128(v2)) => Type::Boolean(v1 == v2),
            (Type::UInt8(v1), Type::UInt8(v2)) => Type::Boolean(v1 == v2),
            (Type::UInt16(v1), Type::UInt16(v2)) => Type::Boolean(v1 == v2),
            (Type::UInt32(v1), Type::UInt32(v2)) => Type::Boolean(v1 == v2),
            (Type::UInt(v1), Type::UInt(v2)) => Type::Boolean(v1 == v2),
            (Type::UInt64(v1), Type::UInt64(v2)) => Type::Boolean(v1 == v2),
            (Type::UInt128(v1), Type::UInt128(v2)) => Type::Boolean(v1 == v2),
            (Type::Float32(v1), Type::Float32(v2)) => Type::Boolean(v1 == v2),
            (Type::Float64(v1), Type::Float64(v2)) => Type::Boolean(v1 == v2),
            (Type::Char(v1), Type::Char(v2)) => Type::Boolean(v1 == v2),
            (Type::String(v1), Type::String(v2)) => Type::Boolean(v1.eq(&v2)),
            (Type::Boolean(v1), Type::Boolean(v2)) => Type::Boolean(v1 == v2),
            (Type::Address(v1), Type::Address(v2)) => Type::Boolean(v1 == v2),
            (Type::Pointer(v1), Type::Pointer(v2)) => Type::Boolean(v1 == v2),
            _ => Type::Boolean(false),
        },
        OpPrim2::NotEqual => match (t1, t2) {
            (Type::None, Type::None) => Type::Boolean(false),
            (Type::Int8(v1), Type::Int8(v2)) => Type::Boolean(v1 != v2),
            (Type::Int16(v1), Type::Int16(v2)) => Type::Boolean(v1 != v2),
            (Type::Int32(v1), Type::Int32(v2)) => Type::Boolean(v1 != v2),
            (Type::Int(v1), Type::Int(v2)) => Type::Boolean(v1 != v2),
            (Type::Int64(v1), Type::Int64(v2)) => Type::Boolean(v1 != v2),
            (Type::Int128(v1), Type::Int128(v2)) => Type::Boolean(v1 != v2),
            (Type::UInt8(v1), Type::UInt8(v2)) => Type::Boolean(v1 != v2),
            (Type::UInt16(v1), Type::UInt16(v2)) => Type::Boolean(v1 != v2),
            (Type::UInt32(v1), Type::UInt32(v2)) => Type::Boolean(v1 != v2),
            (Type::UInt(v1), Type::UInt(v2)) => Type::Boolean(v1 != v2),
            (Type::UInt64(v1), Type::UInt64(v2)) => Type::Boolean(v1 != v2),
            (Type::UInt128(v1), Type::UInt128(v2)) => Type::Boolean(v1 != v2),
            (Type::Float32(v1), Type::Float32(v2)) => Type::Boolean(v1 != v2),
            (Type::Float64(v1), Type::Float64(v2)) => Type::Boolean(v1 != v2),
            (Type::Char(v1), Type::Char(v2)) => Type::Boolean(v1 != v2),
            (Type::String(v1), Type::String(v2)) => Type::Boolean(v1.ne(&v2)),
            (Type::Boolean(v1), Type::Boolean(v2)) => Type::Boolean(v1 != v2),
            (Type::Address(v1), Type::Address(v2)) => Type::Boolean(v1 != v2),
            (Type::Pointer(v1), Type::Pointer(v2)) => Type::Boolean(v1 != v2),
            _ => Type::Boolean(true),
        },
        OpPrim2::Greater => match (t1, t2) {
            (Type::Int8(v1), Type::Int8(v2)) => Type::Boolean(v1 > v2),
            (Type::Int16(v1), Type::Int16(v2)) => Type::Boolean(v1 > v2),
            (Type::Int32(v1), Type::Int32(v2)) => Type::Boolean(v1 > v2),
            (Type::Int(v1), Type::Int(v2)) => Type::Boolean(v1 > v2),
            (Type::Int64(v1), Type::Int64(v2)) => Type::Boolean(v1 > v2),
            (Type::Int128(v1), Type::Int128(v2)) => Type::Boolean(v1 > v2),
            (Type::UInt8(v1), Type::UInt8(v2)) => Type::Boolean(v1 > v2),
            (Type::UInt16(v1), Type::UInt16(v2)) => Type::Boolean(v1 > v2),
            (Type::UInt32(v1), Type::UInt32(v2)) => Type::Boolean(v1 > v2),
            (Type::UInt(v1), Type::UInt(v2)) => Type::Boolean(v1 > v2),
            (Type::UInt64(v1), Type::UInt64(v2)) => Type::Boolean(v1 > v2),
            (Type::UInt128(v1), Type::UInt128(v2)) => Type::Boolean(v1 > v2),
            (Type::Float32(v1), Type::Float32(v2)) => Type::Boolean(v1 > v2),
            (Type::Float64(v1), Type::Float64(v2)) => Type::Boolean(v1 > v2),
            (Type::Char(v1), Type::Char(v2)) => Type::Boolean(v1 > v2),
            (Type::String(v1), Type::String(v2)) => Type::Boolean(v1.cmp(&v2).is_lt()),
            _ => panic!("Greater only works on two of the same number/string types."),
        },
        OpPrim2::Less => match (t1, t2) {
            (Type::Int8(v1), Type::Int8(v2)) => Type::Boolean(v1 < v2),
            (Type::Int16(v1), Type::Int16(v2)) => Type::Boolean(v1 < v2),
            (Type::Int32(v1), Type::Int32(v2)) => Type::Boolean(v1 < v2),
            (Type::Int(v1), Type::Int(v2)) => Type::Boolean(v1 < v2),
            (Type::Int64(v1), Type::Int64(v2)) => Type::Boolean(v1 < v2),
            (Type::Int128(v1), Type::Int128(v2)) => Type::Boolean(v1 < v2),
            (Type::UInt8(v1), Type::UInt8(v2)) => Type::Boolean(v1 < v2),
            (Type::UInt16(v1), Type::UInt16(v2)) => Type::Boolean(v1 < v2),
            (Type::UInt32(v1), Type::UInt32(v2)) => Type::Boolean(v1 < v2),
            (Type::UInt(v1), Type::UInt(v2)) => Type::Boolean(v1 < v2),
            (Type::UInt64(v1), Type::UInt64(v2)) => Type::Boolean(v1 < v2),
            (Type::UInt128(v1), Type::UInt128(v2)) => Type::Boolean(v1 < v2),
            (Type::Float32(v1), Type::Float32(v2)) => Type::Boolean(v1 < v2),
            (Type::Float64(v1), Type::Float64(v2)) => Type::Boolean(v1 < v2),
            (Type::Char(v1), Type::Char(v2)) => Type::Boolean(v1 < v2),
            (Type::String(v1), Type::String(v2)) => Type::Boolean(v1.cmp(&v2).is_gt()),
            _ => panic!("Less only works on two of the same number/string types."),
        },
        OpPrim2::GreaterEqual => match (t1, t2) {
            (Type::Int8(v1), Type::Int8(v2)) => Type::Boolean(v1 >= v2),
            (Type::Int16(v1), Type::Int16(v2)) => Type::Boolean(v1 >= v2),
            (Type::Int32(v1), Type::Int32(v2)) => Type::Boolean(v1 >= v2),
            (Type::Int(v1), Type::Int(v2)) => Type::Boolean(v1 >= v2),
            (Type::Int64(v1), Type::Int64(v2)) => Type::Boolean(v1 >= v2),
            (Type::Int128(v1), Type::Int128(v2)) => Type::Boolean(v1 >= v2),
            (Type::UInt8(v1), Type::UInt8(v2)) => Type::Boolean(v1 >= v2),
            (Type::UInt16(v1), Type::UInt16(v2)) => Type::Boolean(v1 >= v2),
            (Type::UInt32(v1), Type::UInt32(v2)) => Type::Boolean(v1 >= v2),
            (Type::UInt(v1), Type::UInt(v2)) => Type::Boolean(v1 >= v2),
            (Type::UInt64(v1), Type::UInt64(v2)) => Type::Boolean(v1 >= v2),
            (Type::UInt128(v1), Type::UInt128(v2)) => Type::Boolean(v1 >= v2),
            (Type::Float32(v1), Type::Float32(v2)) => Type::Boolean(v1 >= v2),
            (Type::Float64(v1), Type::Float64(v2)) => Type::Boolean(v1 >= v2),
            (Type::Char(v1), Type::Char(v2)) => Type::Boolean(v1 >= v2),
            (Type::String(v1), Type::String(v2)) => Type::Boolean(v1.cmp(&v2).is_le()),
            _ => panic!("GreaterEqual only works on two of the same number/string types."),
        },
        OpPrim2::LessEqual => match (t1, t2) {
            (Type::Int8(v1), Type::Int8(v2)) => Type::Boolean(v1 <= v2),
            (Type::Int16(v1), Type::Int16(v2)) => Type::Boolean(v1 <= v2),
            (Type::Int32(v1), Type::Int32(v2)) => Type::Boolean(v1 <= v2),
            (Type::Int(v1), Type::Int(v2)) => Type::Boolean(v1 <= v2),
            (Type::Int64(v1), Type::Int64(v2)) => Type::Boolean(v1 <= v2),
            (Type::Int128(v1), Type::Int128(v2)) => Type::Boolean(v1 <= v2),
            (Type::UInt8(v1), Type::UInt8(v2)) => Type::Boolean(v1 <= v2),
            (Type::UInt16(v1), Type::UInt16(v2)) => Type::Boolean(v1 <= v2),
            (Type::UInt32(v1), Type::UInt32(v2)) => Type::Boolean(v1 <= v2),
            (Type::UInt(v1), Type::UInt(v2)) => Type::Boolean(v1 <= v2),
            (Type::UInt64(v1), Type::UInt64(v2)) => Type::Boolean(v1 <= v2),
            (Type::UInt128(v1), Type::UInt128(v2)) => Type::Boolean(v1 <= v2),
            (Type::Float32(v1), Type::Float32(v2)) => Type::Boolean(v1 <= v2),
            (Type::Float64(v1), Type::Float64(v2)) => Type::Boolean(v1 <= v2),
            (Type::Char(v1), Type::Char(v2)) => Type::Boolean(v1 <= v2),
            (Type::String(v1), Type::String(v2)) => Type::Boolean(v1.cmp(&v2).is_ge()),
            _ => panic!("LessEqual only works on two of the same number/string types."),
        },
        OpPrim2::BitwiseAnd => match (t1, t2) {
            (Type::Int8(v1), Type::Int8(v2)) => Type::Int8(v1 & v2),
            (Type::Int16(v1), Type::Int16(v2)) => Type::Int16(v1 & v2),
            (Type::Int32(v1), Type::Int32(v2)) => Type::Int32(v1 & v2),
            (Type::Int(v1), Type::Int(v2)) => Type::Int(v1 & v2),
            (Type::Int64(v1), Type::Int64(v2)) => Type::Int64(v1 & v2),
            (Type::Int128(v1), Type::Int128(v2)) => Type::Int128(v1 & v2),
            (Type::UInt8(v1), Type::UInt8(v2)) => Type::UInt8(v1 & v2),
            (Type::UInt16(v1), Type::UInt16(v2)) => Type::UInt16(v1 & v2),
            (Type::UInt32(v1), Type::UInt32(v2)) => Type::UInt32(v1 & v2),
            (Type::UInt(v1), Type::UInt(v2)) => Type::UInt(v1 & v2),
            (Type::UInt64(v1), Type::UInt64(v2)) => Type::UInt64(v1 & v2),
            (Type::UInt128(v1), Type::UInt128(v2)) => Type::UInt128(v1 & v2),
            (Type::Char(v1), Type::Char(v2)) => {
                Type::Char(char::from_u32(v1 as u32 & v2 as u32).unwrap())
            }
            _ => panic!("BitwiseAnd only works on an int number type and an UInt."),
        },
        OpPrim2::BitwiseOr => match (t1, t2) {
            (Type::Int8(v1), Type::Int8(v2)) => Type::Int8(v1 | v2),
            (Type::Int16(v1), Type::Int16(v2)) => Type::Int16(v1 | v2),
            (Type::Int32(v1), Type::Int32(v2)) => Type::Int32(v1 | v2),
            (Type::Int(v1), Type::Int(v2)) => Type::Int(v1 | v2),
            (Type::Int64(v1), Type::Int64(v2)) => Type::Int64(v1 | v2),
            (Type::Int128(v1), Type::Int128(v2)) => Type::Int128(v1 | v2),
            (Type::UInt8(v1), Type::UInt8(v2)) => Type::UInt8(v1 | v2),
            (Type::UInt16(v1), Type::UInt16(v2)) => Type::UInt16(v1 | v2),
            (Type::UInt32(v1), Type::UInt32(v2)) => Type::UInt32(v1 | v2),
            (Type::UInt(v1), Type::UInt(v2)) => Type::UInt(v1 | v2),
            (Type::UInt64(v1), Type::UInt64(v2)) => Type::UInt64(v1 | v2),
            (Type::UInt128(v1), Type::UInt128(v2)) => Type::UInt128(v1 | v2),
            (Type::Char(v1), Type::Char(v2)) => {
                Type::Char(char::from_u32(v1 as u32 | v2 as u32).unwrap())
            }
            _ => panic!("BitwiseOr only works on an int number type and an UInt."),
        },
        OpPrim2::BitwiseXor => match (t1, t2) {
            (Type::Int8(v1), Type::Int8(v2)) => Type::Int8(v1 ^ v2),
            (Type::Int16(v1), Type::Int16(v2)) => Type::Int16(v1 ^ v2),
            (Type::Int32(v1), Type::Int32(v2)) => Type::Int32(v1 ^ v2),
            (Type::Int(v1), Type::Int(v2)) => Type::Int(v1 ^ v2),
            (Type::Int64(v1), Type::Int64(v2)) => Type::Int64(v1 ^ v2),
            (Type::Int128(v1), Type::Int128(v2)) => Type::Int128(v1 ^ v2),
            (Type::UInt8(v1), Type::UInt8(v2)) => Type::UInt8(v1 ^ v2),
            (Type::UInt16(v1), Type::UInt16(v2)) => Type::UInt16(v1 ^ v2),
            (Type::UInt32(v1), Type::UInt32(v2)) => Type::UInt32(v1 ^ v2),
            (Type::UInt(v1), Type::UInt(v2)) => Type::UInt(v1 ^ v2),
            (Type::UInt64(v1), Type::UInt64(v2)) => Type::UInt64(v1 ^ v2),
            (Type::UInt128(v1), Type::UInt128(v2)) => Type::UInt128(v1 ^ v2),
            (Type::Char(v1), Type::Char(v2)) => {
                Type::Char(char::from_u32(v1 as u32 ^ v2 as u32).unwrap())
            }
            _ => panic!("BitwiseXor only works on an int number type and an UInt."),
        },
        OpPrim2::ShiftLeft => match (t1, t2) {
            (Type::Int8(v1), Type::UInt(v2)) => Type::Int8(v1 << v2),
            (Type::Int16(v1), Type::UInt(v2)) => Type::Int16(v1 << v2),
            (Type::Int32(v1), Type::UInt(v2)) => Type::Int32(v1 << v2),
            (Type::Int(v1), Type::UInt(v2)) => Type::Int(v1 << v2),
            (Type::Int64(v1), Type::UInt(v2)) => Type::Int64(v1 << v2),
            (Type::Int128(v1), Type::UInt(v2)) => Type::Int128(v1 << v2),
            (Type::UInt8(v1), Type::UInt(v2)) => Type::UInt8(v1 << v2),
            (Type::UInt16(v1), Type::UInt(v2)) => Type::UInt16(v1 << v2),
            (Type::UInt32(v1), Type::UInt(v2)) => Type::UInt32(v1 << v2),
            (Type::UInt(v1), Type::UInt(v2)) => Type::UInt(v1 << v2),
            (Type::UInt64(v1), Type::UInt(v2)) => Type::UInt64(v1 << v2),
            (Type::UInt128(v1), Type::UInt(v2)) => Type::UInt128(v1 << v2),
            (Type::Char(v1), Type::UInt(v2)) => {
                Type::Char(char::from_u32((v1 as u32) << v2).unwrap())
            }
            _ => panic!("ShiftLeft only works on an int number type and an UInt."),
        },
        OpPrim2::ShiftRight => match (t1, t2) {
            (Type::Int8(v1), Type::UInt(v2)) => Type::Int8(v1 >> v2),
            (Type::Int16(v1), Type::UInt(v2)) => Type::Int16(v1 >> v2),
            (Type::Int32(v1), Type::UInt(v2)) => Type::Int32(v1 >> v2),
            (Type::Int(v1), Type::UInt(v2)) => Type::Int(v1 >> v2),
            (Type::Int64(v1), Type::UInt(v2)) => Type::Int64(v1 >> v2),
            (Type::Int128(v1), Type::UInt(v2)) => Type::Int128(v1 >> v2),
            (Type::UInt8(v1), Type::UInt(v2)) => Type::UInt8(v1 >> v2),
            (Type::UInt16(v1), Type::UInt(v2)) => Type::UInt16(v1 >> v2),
            (Type::UInt32(v1), Type::UInt(v2)) => Type::UInt32(v1 >> v2),
            (Type::UInt(v1), Type::UInt(v2)) => Type::UInt(v1 >> v2),
            (Type::UInt64(v1), Type::UInt(v2)) => Type::UInt64(v1 >> v2),
            (Type::UInt128(v1), Type::UInt(v2)) => Type::UInt128(v1 >> v2),
            (Type::Char(v1), Type::UInt(v2)) => {
                Type::Char(char::from_u32((v1 as u32) >> v2).unwrap())
            }
            _ => panic!("ShiftRight only works on an int number type and an UInt."),
        },
        OpPrim2::SameType => match (t1, t2) {
            (Type::None, Type::None) => Type::Boolean(true),
            (Type::Int8(_), Type::Int8(_)) => Type::Boolean(true),
            (Type::Int16(_), Type::Int16(_)) => Type::Boolean(true),
            (Type::Int32(_), Type::Int32(_)) => Type::Boolean(true),
            (Type::Int(_), Type::Int(_)) => Type::Boolean(true),
            (Type::Int64(_), Type::Int64(_)) => Type::Boolean(true),
            (Type::Int128(_), Type::Int128(_)) => Type::Boolean(true),
            (Type::UInt8(_), Type::UInt8(_)) => Type::Boolean(true),
            (Type::UInt16(_), Type::UInt16(_)) => Type::Boolean(true),
            (Type::UInt32(_), Type::UInt32(_)) => Type::Boolean(true),
            (Type::UInt(_), Type::UInt(_)) => Type::Boolean(true),
            (Type::UInt64(_), Type::UInt64(_)) => Type::Boolean(true),
            (Type::UInt128(_), Type::UInt128(_)) => Type::Boolean(true),
            (Type::Float32(_), Type::Float32(_)) => Type::Boolean(true),
            (Type::Float64(_), Type::Float64(_)) => Type::Boolean(true),
            (Type::Char(_), Type::Char(_)) => Type::Boolean(true),
            (Type::String(_), Type::String(_)) => Type::Boolean(true),
            (Type::Boolean(_), Type::Boolean(_)) => Type::Boolean(true),
            (Type::Address(_), Type::Address(_)) => Type::Boolean(true),
            (Type::Pointer(_), Type::Pointer(_)) => Type::Boolean(true),
            _ => Type::Boolean(false),
        },
    }
}
